package uk.ac.nottingham.cryptography;

import java.util.Arrays;

/**
 * Implements Counter (CTR) mode of operation for block ciphers.
 * <p>
 * CTR mode turns a block cipher into a stream cipher by XORing plaintext or ciphertext
 * with keystream blocks generated by encrypting a nonce concatenated with a counter.
 * Encryption and decryption are identical in CTR mode.
 */
public class CTRMode extends CipherMode {
    private Cipher cipher;           // Underlying block cipher
    private byte[] nonce;            // 128-bit nonce
    private long counter;            // 64-bit counter value
    private int blockSize;           // Cipher block size in bytes

    private byte[] keystream;        // Buffer for encrypted counter block
    private int keystreamPos;        // Current position in keystream
    private byte[] counterBlock;     // Concatenation of nonce || counter

    /**
     * Initialises the CTR mode with the specified cipher, key, and nonce.
     *
     * @param cipher The block cipher to use (e.g., CAST-384).
     * @param key    The key for the cipher.
     * @param nonce  A 16-byte (128-bit) nonce.
     */
    @Override
    public void initialise(Cipher cipher, byte[] key, byte[] nonce) {
        if (nonce.length != 16) {
            throw new IllegalArgumentException("Nonce must be 16 bytes");
        }

        this.cipher = cipher;
        this.nonce = nonce.clone();
        this.blockSize = cipher.getBlockLength() / 8;
        this.keystream = new byte[blockSize];
        this.counterBlock = new byte[blockSize];
        this.counter = 0L;
        this.keystreamPos = blockSize;  // Force keystream generation

        cipher.initialise(key);
    }

    /**
     * Encrypts the provided data in place using CTR mode.
     * CTR mode encryption is symmetric with decryption.
     *
     * @param data The byte array to encrypt.
     */
    @Override
    public void encrypt(byte[] data) {
        process(data);
    }

    /**
     * Decrypts the provided data in place using CTR mode.
     * CTR mode decryption is identical to encryption.
     *
     * @param data The byte array to decrypt.
     */
    @Override
    public void decrypt(byte[] data) {
        process(data);
    }

    /**
     * Processes the given data by XORing it with the keystream.
     * New keystream blocks are generated as needed by encrypting the nonce|counter.
     *
     * @param data The byte array to process.
     */
    private void process(byte[] data) {
        for (int i = 0; i < data.length; i++) {
            if (keystreamPos >= blockSize) {
                generateKeystreamBlock();
            }
            data[i] ^= keystream[keystreamPos++];
        }
    }

    /**
     * Generates a new keystream block by encrypting the current counterBlock.
     * The block is formed by concatenating the nonce and counter (big-endian).
     */
    private void generateKeystreamBlock() {
        Arrays.fill(counterBlock, (byte) 0);

        int nonceLen = blockSize - 8;
        System.arraycopy(nonce, 0, counterBlock, 0, Math.min(nonce.length, nonceLen));

        // Append counter in big-endian order
        for (int b = 0; b < 8; b++) {
            counterBlock[nonceLen + b] = (byte) ((counter >>> (8 * (7 - b))) & 0xFF);
        }

        System.arraycopy(counterBlock, 0, keystream, 0, blockSize);
        cipher.encrypt(keystream);

        keystreamPos = 0;
        counter = (counter + 1) & 0xFFFFFFFFFFFFFFFFL; // Wrap counter on overflow
    }

    /**
     * Sets the internal counter to a specific value from the given byte array.
     * This allows random seeking within the keystream.
     *
     * @param counterBytes A byte array (up to 8 bytes) representing the new counter (big-endian).
     */
    @Override
    public void seek(byte[] counterBytes) {
        counter = 0;
        for (int i = 0; i < counterBytes.length && i < 8; i++) {
            counter = (counter << 8) | (counterBytes[i] & 0xFF);
        }
        keystreamPos = blockSize; // Force regeneration on next use
    }
}



